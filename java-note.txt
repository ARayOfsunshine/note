java当中的数据类型分别为:
基本数据类型：
（1）：整数类型：byte(1个字节长度),short(2个字节长度),int(4个字节长度),long(8个字节长度)，float(4个字节长度),double(8个字节长度)。
（2）：布尔类型：true,false
（3）：字符类型：char(2个字节长度)
（4）：1个字节占8个二进制位。定义long类型时后面的定义的数值可以加或者不加l。定义小数值时为float类型时数值尾部一定要加f，因为java默认的小数类型为double。
（5）：数值的运算：自动转换，只要有byte,short,int,char它们之间进行运算都会被自动转换为int类型。小的表数范围或者变量可以自动向大的表述范围类型转换。
	           强制转换，小的定义类型转换大的定义类型要是用强制装换类型如：int a=(int)13.4。注意强制类型转换的前提是不能超过转换后的表数范围，不然会失去精度。布尔值(boolean)不能转换任何值

方法：
方法的重载定义：函数名相同，但是参数个数或参数类型不同。意义：提升代码的阅读和可复用性。

数组的定义有三种：
（1）：int[] arr=new int[4];创建一个数组并指定数组的长度。没有给数组给定值。初始值由定义的类型决定。整数类型的初始值为0，小数类型的初始值为0.0，布尔类型的初始值为false，字符类型的初始值为' '。
（2）：int[] arr={1,2,3,4};创建一个数组并给数组赋值，长度由赋值决定。
（3）：int[] arr=new int[]{1,2,3,4};创意数组并赋值，与第二种定义方法的不用是需要时可以直接匿名使用（int[]{1,2,3,4}）。

类：
（1）：在类定义的变量被称为成员变量，或者叫类的属性。成员变量是有初始值的。
（2）：局部变量和成员变量。局部变量定义在方法或者代码块中，成员变量定义在类当中。局部变量都是存储在栈内存当中的，而成员变量在存储在堆内存当中。
（3）：面向对象的特性：封装：目的是提高数据的安全性，通过封装可以实现对属性的访问权限控制，同时增加了代码的可维护性。
（4）：构造器：作用：创建对象，给对象赋予初始值。构造器本身是一个方法，没有返回值，没有void。构造器的方法名必须和类名一致。在方法中定义可以初始化的参数列表。
               格式:权限修饰符 方法名（类名）(args){};调用时int o=new 类名(args);注意：当定义了构造器方法有参数时，默认构造器的方法就会被覆盖。
（5）：this关键字：在两种情况下使用，一种是在对象的方法当中，this指向类构造出来的实例对象，在类的方法中可以使用this来区分类的成员变量与方法当中参数名相同的情况。	
                  另一种是情况是在构造器方法当中使用，this(args);构造器中调用其他构造器且必须是代码当中第一行。	
（6）：static关键字：用在定义类属性时，使用类名.属性，调用或者实例对象调用。static能被对象调用的原因是因为类的初始化声明周期很早就初始化了，所以对象可以调用。
                    类属性可以被每个构造出来的实例对象共享。
					用在定义类方法时，都是可以通过类和对象来调用的，类方法的初始化很早。类方法与普通方法的区别在于初始化的时间不同，类方法的初始化时间要比普通方法要早。
					类属性和类方法在class文件进入jvm时，就被初始化了，jvm执行完毕class文件后类属性和类方法也就消失了。所以类方法当中不能调用对象的属性以及方法。
                    用在静态代码块当中，用于初始化资源。

单例设计模式：（又称懒汉模式）
（1）：单例设计模式指一个类只能创建一个对象来做属性或方法的调用者。
（2）：步骤：1,私有化构造器（不让外部通过new来创建一个对象，这样就没办法通过new来创建多个不同的实例对象。）
            2,通过类的方法来暴露构造器给外部方法，重而使外部能够创建一个对象。（私有化属性或者私有化方法不能外部直接调用，但是通过类的方法就能互相调用。）
			3,在暴露类的构造方法当中使用一个类属性，类型为引用类型的类变量来存储构建出来的实例对象。（通过判断来做类的创建，创建过了就直接返回类属性类的数据类型从而达到只能创建了一个类的构建方法）。
			4，外部调用的使用是通过类的方法来创建只有一个对象。

类的继承：
（1）：子类继承父类使用extends关键字，子类可以多层继承，但是不能同时继承多个父类。
（2）：super作为对象使用可以直接调用父类的方法以及属性，在子类使用父类的方法或属性时，子类默认构造器类自动的调用super()来执行父类的构造器。
（3）：方法重写指父类方法不能满足子类的所需要更具体的方法从而重新定义。（重写父类是权限修饰符，返回值，方法名，参数个数和参数类型相同）。
（4）：final关键字定义变量，这个变量就不能重新赋值。作为对象的属性，即定义时就要给初始值，或者在构造器初始化时就要给初始值。用作定义类时，不能被继承。
（5）：抽象类（关键字abstract）。抽象类指具有相同的行为或方法，但有不同的具体实现。抽象类不能构造出实例对象，只能被继承。抽象方法一定是定义在抽象类上，抽象类不一定有抽象方法。
       抽象类的方法被子类继承，子类必须实现抽象类的方法。抽象类方法不能与private,static,final共存。

接口和多态：
（1）：接口定义使用interface 接口名来实现接口。接口的所有方法默认都是抽象方法。接口不能创建实例对象，只能通过类来实现（implement）接口的使用。
（2）：接口中的方法不能喝private,static,final共存。
（3）：接口可以定义“属性”。可以通过类的的实例访问（不推荐），也可以通过接口名来方法。这个“属性”是一个常量。推荐默认是public static final。常量的定义规范是使用大写单词之间使用下滑线“_”来分割。
（4）：接口的实现可以多层实现，也可以同时对多个接口同时实现，对接口的方法实现必须具体化。
（5）： jdk1.8以上的语法，接口可以是用default默认一个抽象方法的实现。如果子类没有实现接口的方法，则可以使用接口定义的默认方法。
（6）：父子类之间的转换：1，使用父类的的类型引用来接受子类的实例对象，调用父类和子类同时拥有的方法，此时调用的是子类的方法，但是如果调用子类的特有方法会出现报错。父类引用调用属性是调用父类的属性。
                        2，父类转子类不能自动完成，父类转换成子类的前提是父类的真身就是这个子类,转回子类就可以访问子类的方法和属性。
						3，抽象类和接口做为父类同样符合上述理论，注意的是接口没有属性。
（7）：多态：1，子类继承父类，不仅仅是抽象类，父类也可以是普通类，子类对父类的方法进行重写。
            2，子类的实例引用给到父类的类型，会自动转换，这时可以通过方法来制定调用子类的方法。
（8）：包：包就是文件夹，作用:对类做分类管理。可以区分同名不同包的类。语法:package。包必须定义在第一行，包的名字必须是英文小写,package 包名（不同级别用.来分割）。
          编译：javac -d . 文件名。 运行：java 包名.文件名。
		  类的引入：前提是权限修饰符是public。1,如果两个类在相同的包内，可以不用引入类就能直接使用。2,如果两个类不在同一个包类，必须引入类才能使用。引入语法：import 包名.文件名
（9）：scanner（扫描器）：作用在代码测试当中，可以在控制台输入参数进行测试，api在java.util包当中，需要引入才能使用。（只有在包java.lang的类才不需要被引入）。


内部类和object：
（1）：内部类就是在内部的类，内部类创建形式：Outter.Inner inner=new Outter().new Inner();
（2）：外部类的方法可以直接创建内部类的实例对象。通过内部类的方法也可以暴露外部类的属性和方法。
（3）：匿名内部类对接口或者抽象类的实现直接创建对象实例后接一个代码块表示匿名的类对接口和抽象方法的实现。
（4）：权限修饰符，public,praivte,protect,默认。应用在类，属性，方法上。在不同的情况下访问的权限受到限制。
（5）：对类的实例对象实际上隐式的调用了object根对象的toString方法。

异常：
（1）：try{代码可能出现运行错误的地方进行捕获}catch(Exception e){ 对错误的信息进行抛出的执行地方};catch后面还能接着捕获错误，前提是捕获错误的范围不能超过后面catch捕获的范围，不然后面的catch将不执行。
（2）：try{}catch(){}finally{}:finally用来执行最终的代码区域，不管有没有捕获到异常的。且finally代码块中是唯一可以出现第二次return的地方。
（3）：执行器的异常会自动的往上面的代码抛出异常，而编译器的异常要手动声明的异常抛出。
（4）：自定义异常，通常是抛出运行时的异常。throw new 自定义异常类。  自定义类异常通常继承RuntimeException。

字符串：
（1）：字符串的定义分为常量的方式定义以及类的形式定义。字符串常量定义，字符串定义后不能再进行修改，字符串的常量是共享的。字符串是一个类，在内存里是以地址存储的。字符串的拼接实际上生成了新的存储地址。
（2）：字符串以类创建，其中字符串类有许多的构造器，传入不同的参数，以不同的形式返回。例：String s= new String(new char[]{'a','b','c'},索引的开始，结束的长度length)。
（3）：字符串常量定义与类创建的字符串区别：如果用类的方式定义字符串常量，就会在堆中创建一个对象，并会去字符串常量池中寻找这个常量，如果没有就会在字符串常量池中创建，并堆中的字符串对象对应用字符串量池中的对象。实际创建了两个对象。
       如果在字符串常量池中已经定义了，在堆中就直接引用字符串常量池中的对象。实际只创建了一个对象。前提是看创建创建字符串类时，字符串常量池是否已经存在字符串的定义。
（4）：空字符串与null的区别。如果字符串是空，是有地址引用的，字符串的长度为0，而null是没有引用地址的，不能使用null的进行操作了。
（5）：可变字符串StringBuffer。对创建出来的可变字符串追加字符内容是在原有的字符串地址上追加的。并不会重新创建一个新的内存地址。对可变字符串进行追加append()，插入insert(),删除delete()等，具体api文档；


内置类的使用：
（1）：Random类：获取随机数，nextInt(指定的随机数末);Random r=new Random(seed)同过seed种子能够获得一组不变的随机数。
（2）：包装类：基本数据类型做为类来使用，一般来说类有方法以及属性，使用内置好的方法提高效率。int的包装类Integer类，一般用作类型的转换。int,String
（3）：自动装箱与自动拆箱：指基本数据类型来接受本包装类的变量就称为拆箱，把基本数据类型赋值给本包装类就叫做装箱。
（4）：Date对象，在java.util当中，Date d=new Date()；时间的格式化对象：SimpleDateFormat s=SimpleDateFormat(yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E星期数);s.format(d);s.parse()字符串日期解析为时间日期。

集合：
（1）：Collection是所有集合的根类。java.util.Collection;Collection下有两个常用的子类List,Set。
（2）：List下的常用子类有：ArrayList,linkedList,vector。Set下常用的子类有：HashSet,LinkedHashSet,TreeSet。

map和文件类File:
（1）：map集合与collection集合完全是不同的集合，map集合以键值对的方式进行数据存储，并提供了特定方法。
（2）：java.io.File。File类对本地文件的具有操作作用，并提供了许多方法。


IO流 字符流与字节流：
（1）：所有字符流的超类：Reader,Writer。实现的子类：字符输入流FileReader，字符输出流FileWriter。高效缓冲字符输入流BufferedReader。高效缓冲字符输出流BufferedWriter。具体方法API文档。
（2）：所有字节流的超累。InputStream,OutputStream。实现的子类：字节输入流FileInputStream。字节输出流FileOutputStream。高效缓冲字节输入流BufferedInputStream。高效缓冲字节输出流BufferedOutStream。


