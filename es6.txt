let和const命令：
(1)let和const都存暂时性死区:在进入作用域时，未定义变量就使用，后来又定义了变量。变量会绑定在该作用域下。
(2)let和const不能够重复声明。
(3)let和const存在作用域，在外调用会报错。
(4)在块级里面声明函数，会被支持ES6的浏览器认作为var行为，因为环境行为差异太大，应该使用函数表达式的形式在块级作用域下声明函数。
(5)const定义常量，即定义过后不能再次复制改变。但是定义引用值的情况就不一样了。只要不改变定义的内存地址，而改变引用值本身是允许的。(Object.freeze({})  冻结对象)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
变量的解构赋值：
(1)结构赋值写法类似于“匹配模式”。
(2)解构赋值允许设置默认值。默认值是要求全等(===)undefined的情况下才能起效。
(3)解构赋值存在不完全结构。结构不成功的值都会等于undefined
(4)等号右边不具备Iterator接口就会报错。
(5)对象的解构赋值变量的属性必须与属性名相同才会赋值成功。
(6)对象的解构赋值实质是左边的变量与对象的属性相互匹配，真正赋值的是右边。
(7)对象的解构赋值可以取到继承来的属性。
(8)注意点：声明后的变量用于解构赋值要非常小心，因为javascript引擎会理解为一个代码块。let a;{a}={a:1};报错。需要添加括号let a;({a}={a:1})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
字符串的扩展：
(1)判断字符串中是否包含另外一个字符串。es5:indexof；es6:includes()是否包含,startsWith()是否以开头,endsWith()是否以结尾。返回值都是boolean值。都可以传入第二个参数表示开始搜索的位置
(2)字符串重复：repeat();参数：重复的次数,注意不能为复制和infinity，小数会被取整值。
(3)字符串补全长度功能:padStart(),padEnd()；第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。
(4)模板字符串：``，将会保留换行和缩进。模板字符串当中引用变量以${}写在里面。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
数值的扩张：
(1)Number.isFinite()用来检查一个数值是否为有限的,注意，如果参数类型不是数值，Number.isFinite一律返回false。
(2)Number.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，Number.isNaN一律返回false。
(3)Number.parseInt(), Number.parseFloat():ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
(4)Number.isInteger()用来判断一个数值是否为整数。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
函数的扩展:
(1)函数参数支持设置默认值。函数参数不能有同名参数。函数参数是默认声明的，不能再使用let或const再次定义。
(2)函数参数的默认值具有独自的作用域。会先取括号内定义的，如果没有才会取得外部定义同名的值。
(3)函数rest参数。（形式为...变量名），解决了参数传入过多变量名多的问题。注意：reset参数只能放在最后一个参数上，不然会报错。函数的length属性不包括reset参数。
(4)箭头函数:如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。(a,b)=>return a+b;
注意：1,函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。(this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。)
      2,不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
      3,不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
      4,不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
数组的扩展：
(1)扩展运算符:...;它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。注意：扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
(2)任何定义了遍历器（Iterator）接口的对象都可以用扩展运算符转为真正的数组。[...nodeList]
(3)如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。
(4)Array.from()方法可以将类数组和具有遍历器（Iterator）接口的对象转为真数组。Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
(5)Array.of：方法用于将一组值，转换为数组。
(6)Array.prototype.find()方法，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。第二个参数是指定回调函数的this指向。
(7)Array.prototype.findIndex()，同样接受一个一个回调函数。找到第一个符合成员所在数组的下标。没有则返回-1;
(8)Array.prototype.entries()，Array.prototype.keys() 和Array.prototype.values()方法返回的是遍历器接口(Iterator); 可以使用 for of遍历得到组数对应的数组下标，数组元素，和数组的下标和元素。也可以调用遍历器接口方法next()方法得到对应信息。
(9)数组实例的 Array.prototype.includes()方法表示是否包含给定的值。返回值值为boolean。
(10)Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。参数：表示要拉平的层数，默认是1，如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。
(11)Array.prototype.flatMap()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组,默认只能展开一层。[2, 3, 4].flatMap((x) => [x, x * 2])// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
对象的扩展：
(1)属性的简洁表示法 例如：const={foo}  //等于const={foo:foo}
(2)属性名表达式 例如:let obj={[preKey]:ture,['a'+'bc']:123}
(3)方法的 name 属性,函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
(4)super 关键字，指向当前对象的原型对象。super关键字只能用在对象的方法上面，而且还要是对象方法的简写法。
(5)对象的扩展运算符,对象的扩展运算符等同于使用Object.assign()方法。
(6)Object.is()它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
(7)Object.assign() 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。如果该参数不是对象，则会先转成对象，然后返回。
(8)Object.keys()，Object.values()，Object.entries()返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名/值/键值对数组。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Symbol:
(1)Symbol的主要作用在于解决对象属性命名时出现的冲突，声明对象属性为Symbol值时表示该属性独一无二，这样就从根本上防止属性名的冲突。
(2)Symbol是一种新的原始数据类型,注意声明时不能new命令。写在对象属性时必须以属性表达式的方式书写，否则就会成为对象属性的字符类型，而不是Symbol类型。
(3)Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述,主要用于区分，参数是对象时，会调用该对象的toString方法。Symbol的参数相等，Symbol之间也是不会相等的。
(4)Object.getOwnPropertySymbols()方法能够返回所有Symbol的属性。Reflect.ownKeys()方法能够返回包括常规键名和 Symbol 键名。
(5)Symbol.for()方法能够使用同一Symbol值，该方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol值     Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
set和map:
(1)set和map数据结构是由本身的构造函数而成的。所以声明时都是使用new操作符构造出来实例。
(2)set类似于数组，而且成员都是唯一的，没有重复。Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。注意点：当set加入两个参数都为NaN时，只返回一个NaN，set认为它们是相等的，但是全等(===）NaN是不等于NaN的。
(3)set的实例方法有add(value)：添加某个值，返回 Set 结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值。Set.prototype.size：返回Set实例的成员总数。
(4)set的遍历方法：keys()：返回键名的遍历器,values()：返回键值的遍历器,entries()方法：返回键值对的遍历器，forEach()方法：使用回调函数遍历每个成员。Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for...of循环遍历 Set。Set结构没有键名，只有键值，或者说键名和键值是同一个值。所以keys方法和values方法的行为完全一致。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
WeakSet:WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
WeakSet 结构有以下三个方法。WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。WeakSet 没有size属性，没有办法遍历它的成员。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(5)map为解决对象传统上只能用字符串当作键的限制，它类似于对象，也是键值对的集合，但是map结构的键的范围不限于字符串，可以是各种类型的的值当做键（包括对象）。
(6)map函数的函数可以是任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构。
(7)map的实例方法：size：成员的总数。set(key, value):set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。get(key)get方法读取key对应的键值，如果找不到key，返回undefined。has(key)has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。clear()clear方法清除所有成员，没有返回值。
(8)map的遍历方法：keys()：返回键名的遍历器。values()：返回键值的遍历器。entries()：返回所有成员的遍历器。forEach()：遍历 Map 的所有成员。 Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。

WeakMa：WeakMap结构与Map结构类似，也是用于生成键值对的集合。
WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proxy:
(1)Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 可以译为“代理器”。
(2) Proxy 构造函数，用来生成 Proxy 实例。构造函数的第一个参数为要拦截的目标对象，第二个参数为一个对象，用来指定拦截的行为。
(3)注意点：要使Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作。如果第二个参数对象没有设置任何拦截，那就等同于直接通向原对象。
(4)proxy支持拦截的操作一共有13种。
1,get(target, propKey, receiver)：拦截对象属性的读取;比如proxy.foo和proxy['foo']。
2,set(target, propKey, value, receiver)：拦截对象属性的设置;比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
3,has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
4,deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值;
5,ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
6,getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
7,defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
8,preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
9,getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
10,isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。11,setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
12,apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
13,construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Reflect：
(1) 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。
(2)修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
(3)让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
(4)Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
promise对象：
(1)Promise 是异步编程的一种解决方案，比传统的解决方案――回调函数和事件――更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
(2)Promise对象是一个构造函数，用来生成Promise实例。Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
(3)resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
(4)返回的Promise实例中，有实例方法Promise.prototype.then()来接受返回对应状态的信息。then方法一共可以传递两个回调函数，第一个参数为成功的回调函数，第二个参数为失败的回调函数。第二个可选。
(5)Promise实例还有专门指定出现错误后的回调函数:Promise.prototype.catch();用来接函数。
(6)Promise.prototype.finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。
(7)Promise.all()方法与Promise.race()。用于将多个 Promise 实例，包装成一个新的 Promise 实例。

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Iterator和for..of循环：
(1)Iterator遍历器的作用主要有1,为提供各种数据结构统一的访问机制。2,使得数据结构的成员能够按某种次序排列。3,创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
(2)Iterator遍历器接口本质上是一个指针对象，调用next()方法，可以访问数据结构的第成员。
(3)默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）
(4)原生具备 Iterator 接口的数据结构有：1,Array,2,Map,3,Set,4,String,5,TypedArray,6,函数的arguments对象,7,nodeList对象。它们都不用任何处理，就可以被for...of循环遍历。

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Generator:
(1)Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。Generator 函数是一个状态机，封装了多个内部状态。
(2)执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。
(3)定义Generator函数：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
(4)注意点：yield只能用在Generator函数内，用在其他地方会报错。yield被用在表达式内，必须放在圆括号里面。
(5)yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。next方法的传参可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。next方法第一次使用参数是无效的。
(6)Generator.prototype.throw()可以在函数体外抛出错误，然后在 Generator 函数体内捕获。
(7)Generator.prototype.return() 可以返回给定的值，并且终结遍历 Generator 函数。
(8)yield*表达式用来在Generator函数里面调用外面的Generator函数。也可以理解为表明它返回的是一个遍历器对象
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

async 函数:
(1)它就是 Generator 函数的语法糖。async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。
(2)async函数对 Generator 函数的改进，体现在以下四点。
1,内置执行器。不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。
2,更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
3,更广的适用性。而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
4,返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。
(3)async函数内部return语句返回的值，会成为then方法回调函数的参数。async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。
(4)正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。
(5)多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。同时触发:let [foo, bar] = await Promise.all([getFoo(), getBar()]);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

class：
(1)引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
(2)在class类里面有constructor方法,这就是构造方法，而this关键字则代表实例对象。定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。类的写法完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。
(3)类的所有方法都定义在类的prototype属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。类的内部所有定义的方法，都是不可枚举的。
(4)constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，自动调用该方法。如果没有显式定义，一个空的constructor方法会被默认添加。
(5)静态方法:如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。如果静态方法包含this关键字，这个this指的是类，而不是实例。静态方法可以与非静态方法重名。父类的静态方法，可以被子类继承。关于静态属性直接写在构造函数上面，或已经有提案直接用static直接写静态属性。
(6)私有属性和私有方法：使用约定俗成的下划线定义(_)或使用symbol属性的唯一性定义，但是Reflect.ownKeys()方法任然能得到symbol值。而有已经有提案是用#来定义私有属性和私有方法。
(7)new.target属性：new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。注意：被子类继承的new.target属性会返回子类。
(6)Class 可以通过extends关键字实现继承。super关键字表示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例时会报错。在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。
es5的继承实质是先创建实例对象的this,然后在将父类方法添加到this对象上。而es6则完全不同，实质是父类实例化属性以及方法，再加到this对象上，然后用子构造函数修改this。

(7)super关键字：1，第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。2,super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
module:
(1)module模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西,是在运行时加载，而module是在编译时加载。
(2)modeule模块的主要由两个命令构成：export和import。。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
(3)通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。export输出的方式要一一对应的关系，输出的值是动态值，而CommonJS 模块输出的是值的缓存，不存在动态更新。
(4)import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名(5)import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。import命令具有提升效果，会提升到整个模块的头部，首先执行。
(6)模块的整体加载可以使用*号指定一个对象，所有输出值都加载在这个对象上面。
(7)export default命令，为模块指定默认输出。一个模块只能有一个默认输出，因此export default命令只能使用一次。

module的加载：
(1)script标签里面有个type="module"：会等到页面加载完成后在加载脚本。跟defer相同的效果。


